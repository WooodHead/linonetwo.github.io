---
layout: post
title: "搞一个简单的物联网规则引擎"
date: 2017-02-06 21:44:12 +0800
image: 'blog-author.jpg'
description: 做一个 Ruff 物联网项目的手机 APP 和告警触发器规则引擎
main-class: 'backend'
color: '#CDDC39'
tags:
- reasoning
categories: Journal
twitter_text:
introduction: 物联网告警触发器规则引擎的几种写法
---
# 触触触触触发器！

## 背景

现有一个新的有趣项目是做工业 SaaS，其中大量智能化的工业设施上报的数据会流过一个规则引擎。由于感到有趣，以前也看过相关文章，我主动跟 SE 申请负责这个部分，
![工业 SaaS](https://raw.githubusercontent.com/linonetwo/linonetwo.github.io/master/assets/img/posts/ruleengine/rule.png)
感觉计算速度不够的话就会像狂按有声计算器时发出的声音：「归归归归归零…」，但是开发速度不够的话经理会想打我，所以我尝试从简单开始迭代，并先设想一下优化方案。

据产品经理开玩笑说目标用户主要是皮鞋厂长、农民企业家和工人同志，他们比起看监控，更多的精力会花在打麻将上，听了这个我更感到责任重大，为工人同志节省心力，让他们有更多的时间玩麻将，这是很重要的事。这和 GraphQL 做的事情很类似，他们为前端节省心力，让前端有更多的时间玩 Steam。

## 将处理的规则

初期的规则比较简单，大致如下：

设备数据还是生产数据 -> 皮带寿命还是电机寿命 -> 大鱼小鱼等鱼某个值
|
-> 是电流还是电压 -> 大鱼小鱼等鱼某个值

传入的数据大概是：

```json

{
  "timestamp" : "1486174258155",
  "metric" : "temperature",
  "value" : "22",
  "type" : "dht11",
  "id" : "dht11-01",
  "mac" : "5CFG",
  "gateway" : "3044a1000574"
}
```

每个设备 id 可以有多条规则，每条规则都有规则 id，其中一条规则没有通过就通知设备。

用户将用手机一次性配置几个设备的规则，组成一个规则组。一个用户一次只开启一个规则组，且同时有多个用户在使用这个系统。

## JSON 配置触发器

由于研发时间紧迫，我先到开源包数量最多的 npm 仓库中寻找能简单地一条条过规则的规则引擎库，这样的库配置简单上手容易，初期也不容易被高端的规则引擎在运行速度上拉开距离。

很多库不明显地载入配置，让动态切换规则集变成很麻烦的事情。最终我选用了 ```json-rules-engine```，它用 JSON 树状结构来描述布尔表达式，声明式地写规则，这样从数据库载入当前启用的规则集变得较为容易了。

```javascript
// 要求的规则格式
{
  "event":{
    "type":"HighCurrentAlarm",
    "params":{
      "message":"Device is in high current."
    }
  },
  "conditions":{
    "any":[
      {
        "all":[
          {
            "fact":"deviceId",
            "value":"dht13",
            "operator":"equal"
          },
          {
            "fact":"metric",
            "value":"current",
            "operator":"equal"
          },
          {
            "fact":"value",
            "value":8,
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

在数据库中我们只存储 conditions 和 message，因此存储为：

```javascript

{
  name: 'name of rule',
  message: 'fire in the hole',
  deviceId: 'dht13'
  conditions: {
  }
}
```

规则的粒度是设备级，也就是说对每个设备会有零或一条规则，我用 ```deviceId``` 能唯一标识出一条规则。

当启用的规则组有变化，SaaS 后台程序会发一个 Pull Request，让规则引擎去拉取最新的所有用户启用的规则的列表，并载入规则引擎。这个过程中规则引擎是不工作的，时间大概是一秒以内，这时会有一个简单的存储把一秒内收到的数据缓冲一下，等规则引擎装载完毕后再计算它们。

## 定时任务

另有一个需求是计算聚合数据，也就是如「过去五分钟电流的平均值」的数据，要判断它是否高于 30 这样。

我们在保存规则时用一个 boolean 字段表示这条规则是否是用于计算聚合数据，如果是，则规则引擎在加入这条规则之余，还启动一个计时器，每五分钟调用 API 向时序数据库请求一次「过去五分钟电流的平均值」，然后用这个数据来跑一遍规则引擎。

```javascript

{
  name: 'name of rule',
  message: 'fire in the hole',
  aggregated: true, // Added
  scale: 5, // Added
  deviceId: 'dht13'
  conditions: {
  }
}
```

如何管理一大坨的计时器成了一个问题，因为我们需要解决：

1. 如何标识出每个计时器，以便关闭计时任务
2. 如何在多个负载均衡的规则引擎实例间共享计时器

对我司前端写得最好的后端程序员进行问询后，我决定采用 Redis，它会在 key 过期时通知客户端，作为定时器使用。以规则的 key 作为 Redis 的 key，也解决了关闭计时任务的问题，我们只需要在新拉取的规则列表后用 Redis 的 Key 集合减去规则列表 Key 集合，就知到了要关闭的定时任务有哪些啦。

## DSL 方案

曾见过前辈用 Elixir 的模式匹配来处理大量的规则[[1]](#1)，结合以前看鲍捷对推理的吐槽[[2]](#2)稍微能理解一点其中的辛苦，但当时看着更多是不明觉厉。简单入门了一下 Elixir，写了一个 demo 如下：

```elixir

defmodule RuleEnginePlayground do

  defp format_compare(rule) do
    re_less_than_frag = ~r/(\S+) less than (\S+)/i
    re_larger_than_frag = ~r/(\S+) larger than (\S+)/i
    re_equal_to_frag = ~r/(\S+) equal to (\S+)/i

    rule
    |> (fn (rule) -> Regex.replace(re_less_than_frag, rule, "^\\g{1} < \\g{2}") end).()
    |> (fn (rule) -> Regex.replace(re_larger_than_frag, rule, "^\\g{1} > \\g{2}") end).()
    |> (fn (rule) -> Regex.replace(re_equal_to_frag, rule, "^\\g{1} = \\g{2}") end).()
  end

  @doc """
  exampel:
    format_is("aaa is bbb")
    "^aaa = bbb"
  """
  def format_is(rule) do
    re_is_literal_frag = ~r/(\S+) is "(\S+)"/i
    re_is_atom_frag = ~r/(\S+) is ([^"\s]+)/i

    rule
    |> (fn (rule) -> Regex.replace(re_is_literal_frag, rule, "^\\g{1} = \"\\g{2}\"") end).()
    |> (fn (rule) -> Regex.replace(re_is_atom_frag, rule, "^\\g{1} = :\\g{2}") end).()
  end

  def parse(rule) do
    rule
    |> format_is
    |> format_compare
    |> Code.string_to_quoted
  end

  @doc """
      funcs = RuleEnginePlayground.parse_db()
      Enum.at(funcs, 0).()
  """
  def parse_db() do
    rules = [
      %{id: 0, rule: "type is \"dht11\" and metric is temperature and value less than 50"},
      %{id: 1, rule: "type is \"dht12\" and metric is current and value larger than 50"},
    ]

    rules
    |> Enum.to_list
    |> Enum.map(fn %{:id => id, :rule => rule} ->
      case parse(rule) do
        {:ok, quoted_rule} ->
          fn -> Code.eval_quoted(quoted_rule)
          end
        {:error, {_, error, token}} -> Logger.warn("Quote Failed: {#{id}, #{rule}}")
      end
    end)
  end
end
```

存在数据库中的一条规则可能是 「type is "dht11" and metric is temperature and value less than 50」，有一个它独一无二的 id。

其中 type 全部 escape 掉，metric 是枚举值，value 是整型。如果可以确定对于每一对 type 和 metric 都只有一条规则，那么可以将它们作为 key，生成 Elixir 下的多态函数，科里化出一个参数接受整型的 value。

## 语句就这么存数据库好么

复旦的同学表示这次的业务不是很复杂，没必要追求那么高的速度，直接把描述规则的 JS 语句存在数据库里，需要的时候拼起来执行不就好啦。为了早点实现 MVP，我理解他的想法，我本着前端素养加了前后端验证，把前端传来的符号验证无害后拼成语句存入数据库，实现如下：

## 存个符号

后端小哥说如果这和将符号存在数据库里，取用时拼接成程序区别只在计算的顺序上有不同。

## 参考文献

### [<span id="1">Policy Engine 的前世今生 - 陈天</span>](https://zhuanlan.zhihu.com/p/24749368)

### [<span id="2">精益知识图谱方法论</span>](http://blog.memect.cn/wp-content/uploads/2016/09/2016-09-19_ccks.pdf)
