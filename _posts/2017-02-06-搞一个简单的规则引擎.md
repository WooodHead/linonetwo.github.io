---
layout: post
title: "搞一个简单的物联网规则引擎"
date: 2017-02-06 21:44:12 +0800
image: 'blog-author.jpg'
description: 做一个 Ruff 物联网项目的手机 APP 和告警触发器规则引擎
main-class: 'backend'
color: '#827717'
tags:
- reasoning
- rxjs
categories: Journal
twitter_text:
introduction: 物联网告警触发器规则引擎的几种写法
---
# 触触触触触发器！

## 背景

现有一个新的有趣项目是做工业 SaaS，其中大量智能化的工业设施上报的数据会流过一个规则引擎。由于感到有趣，以前也看过相关文章，我主动跟 SE 申请负责这个部分，
![工业 SaaS](https://raw.githubusercontent.com/linonetwo/linonetwo.github.io/master/assets/img/posts/ruleengine/rule.png)
感觉计算速度不够的话就会像狂按有声计算器时发出的声音：「归归归归归零…」，但是开发速度不够的话经理会想打我，所以我尝试从简单开始迭代，并先设想一下优化方案。

据产品经理开玩笑说目标用户主要是皮鞋厂长、农民企业家和工人同志，他们比起看监控，更多的精力会花在打麻将上，听了这个我更感到责任重大，为工人同志节省心力，让他们有更多的时间玩麻将，这是很重要的事。这和 GraphQL 做的事情很类似，他们为前端节省心力，让前端有更多的时间玩 Steam。

## 将处理的规则

初期的规则比较简单，大致如下：

设备数据还是生产数据 -> 皮带寿命还是电机寿命 -> 大鱼小鱼等鱼某个值
|
-> 是电流还是电压 -> 大鱼小鱼等鱼某个值

传入的数据大概是：

```javascript

type DeviceRawData = {
  timestamp: number,
  metric: string,
  value: number,
  type: string,
  id: string,
  mac: string,
  gateway: string
}
```

每个设备 id 可以有多条规则，每条规则都有规则 id，其中一条规则没有通过就通知设备。

用户将用手机一次性配置几个设备的规则，组成一个规则组。也就是说一个用户一次只开启一个规则组，同时监控多个设备状态，且同时有多个用户在使用这个系统。

## JSON 配置触发器

由于研发时间紧迫，我先到开源包数量最多的 npm 仓库中寻找能简单地一条条过规则的规则引擎库，这样的库配置简单上手容易，初期也不容易被高端的规则引擎在运行速度上拉开距离。

很多库不明显地载入配置，让动态切换规则集变成很麻烦的事情。最终我选用了 ```json-rules-engine```，它用 JSON 树状结构来描述布尔表达式，声明式地写规则，这样从数据库载入当前启用的规则集变得较为容易了。

```javascript
// 要求的规则格式
{
  "event":{
    "type":"HighCurrentAlarm",
    "params":{
      "message":"Device is in high current."
    }
  },
  "conditions":{
    "any":[
      {
        "all":[
          {
            "fact":"deviceId",
            "value":"dht11-01",
            "operator":"equal"
          },
          {
            "fact":"value",
            "value":8,
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

在数据库中我们只存储 conditions 和 message，因此存储为：

```javascript

{
  name: 'name of rule',
  message: 'fire in the hole',
  deviceId: 'dht11-01'
  conditions: {
  }
}
```

规则的粒度是设备级，也就是说对每个设备会有零或一条规则，我用 ```deviceId``` 能唯一标识出一条规则，然后 condition 里用 deviceId 来判断是否要实施规则，用 value 来判断是否出现险情。

### 例子

> 电流超过 100 mA

设备会每五分钟上传一次数据。

```json

{
  "name": "大电流规则",
  "message": "电流过高！",
  "deviceId": "dht11-01",
  "conditions": {
    "any": [
      {
        "all": [
          {
            "fact":"deviceId",
            "value":"dht11-01",
            "operator":"equal"
          },
          {
            "fact":"value",
            "value": 3,
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

当启用的规则组有变化，SaaS 后台程序会发一个 Pull Request，让规则引擎去拉取最新的所有用户启用的规则的列表，并载入规则引擎。这个过程中规则引擎是不工作的，时间大概是一秒以内。本来这时我设想会有一个简单的存储把一秒内收到的数据缓冲一下，等规则引擎装载完毕后再计算它们，但考虑到业务量初期还很小，物联网设备数据上报五分钟才一次，就此作罢。

## 定时任务

另有一个需求是计算聚合数据，也就是如「过去五分钟电流的平均值」的数据，要判断它是否高于 30 这样。

我们在保存规则时用一个 boolean 字段表示这条规则是否是用于计算聚合数据，如果是，则规则引擎在加入这条规则之余，还启动一个计时器，每五分钟调用 API 向时序数据库请求一次「过去五分钟电流的平均值」，然后用这个数据来跑一遍规则引擎。

```javascript

type Rule = {
  name: string,
  message: string,
  aggregated: boolean, // Added
  window: string, // Added
  deviceId: string,
  conditions: Conditions
}

type Conditions = {
  any?: Array<Conditions>,
  all?: Array<Conditions>
}
```

### 例子

> 过去五分钟平均电流超过 100 mA

利用时序数据库 API 查询过去 5 分钟的平均电流值。

```json

{
  "name": "大电流规则",
  "message": "过去 5 分钟平均电流过高！",
  "deviceId": "dht11-01",
  "aggregated": true,
  "window": "300s",
  "conditions": {
    "any": [
      {
        "all": [
          {
            "fact":"deviceId",
            "value":"dht11-01",
            "operator":"equal"
          },
          {
            "fact":"value",
            "value": 3,
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

可以看到 ```conditions``` 都没变化，只是多了 ```aggregated``` 和 ```window``` 两项。

### 计时器

如何管理一大坨的计时器成了一个问题，因为我们需要解决：

1. 如何标识出每个计时器，以便关闭计时任务
2. 如何在多个负载均衡的规则引擎实例间共享计时器

对我司前端写得最好的后端程序员进行问询后，我决定采用 Redis，它会在 key 过期时通知客户端，作为定时器使用。后来也搜到可以使用 node-schedule 不顾负载均衡功能更快地完成 MVP，还有好处是不用另起 Redis ，但比起 Redis 效率可能比较有问题。

以规则的 id 作为 Redis 的 key，也解决了关闭计时任务的问题，我们只需要在新拉取的规则列表后用 Redis 的 Key 集合减去规则列表 id 集合，就知到了要关闭的定时任务有哪些；用规则列表 id 集合减去 Redis 的 Key 集合，就知到了要开启的定时任务有哪些啦，有点像做了个异或 toggle。

当某个定时任务开始时，我们用这个 key 去获取其对应的 window，然后用 id 和 window（时间段）从时序数据库中读取这段时间的平均值，用来跑规则引擎。因为 key 过期之后就废了，读不了里面的值，我只好用一个过期时间较长（例如 2T + 10000ms）的 key' 来存放 window。

我用一个定时任务对象来管理相关业务，主要实现根据 key 增加删除定时任务、自动给定时任务续命、调用数据 API 和规则引擎的功能。定时任务和设备上报数据都要经过同步的规则引擎（形似一个从设备数据到 boolean 的函数），而定时任务是异步数据（要先去请求 API），设备上报数据是随机到达的同步数据，为了统一管理这两种数据，我本来想用前端熟悉的 saga 来做数据流，但考虑它在后端场景下不是很直观，最后考虑采用 RxJs 同时管理规则流和数据流。

对于聚合规则，我们用客户端发出的修改当前规则的请求（会先被 API 网关变成一个 Pull Request）作为一个流，我们如下这么处理，可以看到最终我们得到了关闭定时任务和开启定时任务的操作流：

```javascript
// Async Rule Stream

---r----r--r----r------r-|-> rulesListStream: Observable<Request>

↓ flatMap(getRules) ↓

---r----r--r----r------r-|-> rulesListStream: Observable<Array<Rule>>

↓ map(getAggregated) ↓

---r----r--r----r------r-|-> aggregatedRulesListStream: Observable<Array<Rule>>

↓ map(getDeviceId) ↓
↓ map(diffWithRedis) ↓

---{ openIds: --i--|->, closeIds: --i--|-> }---|-> toCloseAndToOpenTaskId: Observable<ToggleIdStream>
// type ToggleIdStream = {openIds: Observable<string>, closeIds: Observable<string>};

↓ do(closeRedisTask) ↓    ↓ do(openRedisTask) ↓

```

对于聚合规则带来的定时任务，Redis 中 key 的过期会带来一个流，这个 key 本身是设备 id 和 规则 id，我们用它拼出另一个此时还没过期的 key' 去数据库中取 window 和 action，其中 action 用于指定调用哪个 API 来取聚合数据，也可以指定只是返回当前的时间戳。

用 id、window 和 action 调用 API 网关的一个 API 取得 value，最后用 id 和 value 执行 ```runRules```，如果规则匹配到一条险情，调用 API 网关的一个 API 告诉它发生的险情。

数据流如下：

```javascript
// Period Task Stream

---e----e--e----e------e-|-> redisKeyExpireStream: Observable<string>

↓ flatMap(getScale) ↓

---s----s--s----s------s-|-> idAndScaleStream: Array<{deviceId: string, window: string, action: string}>

↓ flatMap(getValue) ↓

---v----v--v----v------v-|-> aggregatedValueStream: Array<{deviceId: string, value: number}>

↓ flatMap(runRules) ↓

---r----r--r----r------r-|-> redisKeyExpireStream: Observable<?Result>
// type Result = {deviceId: string, message: string};

↓ filter(notNull) ↓

--------r-------r--------|-> redisKeyExpireStream: Observable<Result>

↓ do(callbackAPI) ↓

```

对于大约每五分钟、不定期到达一次的非聚合任务，这样来：

```javascript
// Sync Rule Stream

---r----r--r----r------r-|-> deviceRawDataStream: Observable<DeviceRawData>

↓ map(getValue) ↓

---v----v--v----v------v-|-> aggregatedValueStream: Array<{deviceId: string, value: number}>

↓ flatMap(runRules) ↓

---r----r--r----r------r-|-> redisKeyExpireStream: Observable<?Result>

↓ filter(notNull) ↓

--------r-------r--------|-> redisKeyExpireStream: Observable<Result>

↓ do(callbackAPI) ↓

```

这样，主要的逻辑就放在了三条 rx 管理的数据流中，清晰易懂。

### 例子

> 过去5分钟中有三次电流超过 100 mA

先利用时序数据库 API 查询过去 5 分钟电流超过 100 mA的次数……

![百度天工支持的聚合方法](https://github.com/linonetwo/linonetwo.github.io/raw/master/assets/img/posts/ruleengine/%E5%A4%A9%E5%B7%A5.png)

需要先过滤出大于 100 的值，然后再用聚合函数 Count。

```json

{
  "name": "大电流规则",
  "message": "电流 5 分钟内过高 3 次了！",
  "deviceId": "dht11-01",
  "aggregated": true,
  "window": "300s",
  "conditions": {
    "any": [
      {
        "all": [
          {
            "fact":"deviceId",
            "value":"dht11-01",
            "operator":"equal"
          },
          {
            "fact":"value",
            "value": 3,
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

> 新添加的设备，需要在 60 天后更换备件

用一个每天触发一次的定时任务，算一算当今的时间有没有大于需要更换备件的时间。

```json

{
  "name": "换备胎规则",
  "message": "备胎需要更换",
  "deviceId": "dht11-01",
  "aggregated": true,
  "window": "86400s",
  "conditions": {
    "any": [
      {
        "all": [
          {
            "fact":"deviceId",
            "value":"dht11-01",
            "operator":"equal"
          },
          {
            "fact": "time",
            "value": "2018-10-02 17:54:39",
            "operator":"greaterThan"
          }
        ]
      }
    ]
  }
}
```

看起来这套系统能解决目前为止的需求，而且实现简单，部署方便。

## DSL 方案

有了 MVP 方案，就要想着未来怎么优化。曾见过前辈用 Elixir 的模式匹配来处理大量的规则[[1]](#1)，结合以前看鲍捷对推理的吐槽[[2]](#2)稍微能理解一点其中的辛苦，但当时看着更多是不明觉厉。简单入门了一下 Elixir，写了一个 demo 如下：

```elixir

defmodule RuleEnginePlayground do

  defp format_compare(rule) do
    re_less_than_frag = ~r/(\S+) less than (\S+)/i
    re_larger_than_frag = ~r/(\S+) larger than (\S+)/i
    re_equal_to_frag = ~r/(\S+) equal to (\S+)/i

    rule
    |> (fn (rule) -> Regex.replace(re_less_than_frag, rule, "^\\g{1} < \\g{2}") end).()
    |> (fn (rule) -> Regex.replace(re_larger_than_frag, rule, "^\\g{1} > \\g{2}") end).()
    |> (fn (rule) -> Regex.replace(re_equal_to_frag, rule, "^\\g{1} = \\g{2}") end).()
  end

  @doc """
  exampel:
    format_is("aaa is bbb")
    "^aaa = bbb"
  """
  def format_is(rule) do
    re_is_literal_frag = ~r/(\S+) is "(\S+)"/i
    re_is_atom_frag = ~r/(\S+) is ([^"\s]+)/i

    rule
    |> (fn (rule) -> Regex.replace(re_is_literal_frag, rule, "^\\g{1} = \"\\g{2}\"") end).()
    |> (fn (rule) -> Regex.replace(re_is_atom_frag, rule, "^\\g{1} = :\\g{2}") end).()
  end

  def parse(rule) do
    rule
    |> format_is
    |> format_compare
    |> Code.string_to_quoted
  end

  @doc """
      funcs = RuleEnginePlayground.parse_db()
      Enum.at(funcs, 0).()
  """
  def parse_db() do
    rules = [
      %{id: 0, rule: "type is \"dht11\" and metric is temperature and value less than 50"},
      %{id: 1, rule: "type is \"dht12\" and metric is current and value larger than 50"},
    ]

    rules
    |> Enum.to_list
    |> Enum.map(fn %{:id => id, :rule => rule} ->
      case parse(rule) do
        {:ok, quoted_rule} ->
          fn -> Code.eval_quoted(quoted_rule)
          end
        {:error, {_, error, token}} -> Logger.warn("Quote Failed: {#{id}, #{rule}}")
      end
    end)
  end
end
```

这样规则的匹配会被虚拟机自动优化成二叉搜索，运行起来奇快。

存在数据库中的一条规则可能是 「type is "dht11" and metric is temperature and value less than 50」，有一个它独一无二的 id。

其中 type 全部 escape 掉，metric 是枚举值，value 是整型。如果可以确定对于每一对 type 和 metric 都只有一条规则，那么可以将它们作为 key，生成 Elixir 下的多态函数，科里化出一个参数接受整型的 value。

## JS 二叉搜索

由于用 Elixir 处理异步的定时任务比较麻烦（正在考虑 RxElixir，但时间紧迫没法深究），我考虑在 js 规则引擎中实现二叉搜索跑规则。

## 语句就这么存数据库好么

复旦的同学表示这次的业务不是很复杂，没必要追求那么高的速度，直接把描述规则的 JS 语句存在数据库里，需要的时候拼起来执行不就好啦。为了早点实现 MVP，我理解他的想法，我本着前端素养加了前后端验证，把前端传来的符号验证无害后拼成语句存入数据库，实现如下：

## 存个符号

后端小哥说如果这和将符号存在数据库里，取用时拼接成程序区别只在计算的顺序上有不同。

## 参考文献

### [<span id="1">Policy Engine 的前世今生 - 陈天</span>](https://zhuanlan.zhihu.com/p/24749368)

### [<span id="2">精益知识图谱方法论</span>](http://blog.memect.cn/wp-content/uploads/2016/09/2016-09-19_ccks.pdf)

感谢跟我讨论的同志。
