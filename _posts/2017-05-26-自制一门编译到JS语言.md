---
layout: post
title: "自制一门编译到JS语言"
date: 2017-05-26 16:37:19 +0800
image: 'blog-author.jpg'
description: '简述快速实现将外语编译到JS的一种思路'
main-class: 'frontend'
color: '#66CCFF'
tags:
- Rx
- WIP
categories: Review
twitter_text:
introduction: '将一门语言解析为 AST，遍历它自底向上构建 JS 的 AST，并生成 flowtyped ES6'
---
# 自制一门编译到JS语言

## COOL-language

COOL 语言是一门并没有广泛用于课堂教学的面向对象语言，全称是 ClassroomObjectOrientedLanguage，遗憾的是它不能进行物联网、VR、游戏和移动端GUI编程。幸运的是，熟练的情况下我们可以在三天内将它编译成 javascript，让它就像萝莉穿上魔法少女魔装一样，获得强大的能力（误）。

COOL 语言的代码长这样：

```cool
class Main inherits IO {
  jiayimiao(second: Int): Int {
    second + 1
  };

  main(): SELF_TYPE {
    {
      out_string((new Object).type_name().substr(4,1)).
      out_string((isvoid self).type_name().substr(1,3));
      out_string("\n");
    }
  };
};
```

可以看到类型标注和 flowtype、 typescript 是一个路数，花括号和分号也很 C-style。COOL 和 JS 最大的不同是，COOL 是面向表达式（expression）的语言，jiayimiao() 函数直接返回了 second + 1 的结果，main() 函数直接返回了最后一行 out_string() 的结果，而 javascript 是基于语句（statement）的。

expression 和 statement 之间的鸿沟可以通过立即执行函数（IIEF）来填补，除了调用栈容易爆以外没有太大的问题。

## 基本思路

从语言到语言的编译称为 program-transformation，有[很多系统](https://www.wikiwand.com/en/List_of_program_transformation_systems)可以帮你搞定这种工作，但我们需要稍微高一点的灵活性，我希望能得到 COOL 语言的抽象语法树（AST）并把它转换成 babel AST，这样我们能保留下尽可能多的 COOL 代码里的类型标注等信息，然后通过前端常用的 babel 插件系统，例如 flow-stripe-type、 flow-runtime、 transform-class-property 等对 AST 进行自定义的转换，最终输出我们需要的版本的 JS 代码。

## 如何得到 COOL AST

从源代码得到 AST 理论上说需要两步，用词法分析器（lexer）分词，得到切好的一个个词后用语法分析器（parser）。

工程上也需要两步，第二步比较简单，就是把 COOL 的源代码传入下面这个官网给的样例函数（boilerplate）里：

```javascript
// parseCOOL.js
// @ts-check @flow
import antlr4, { InputStream, CommonTokenStream } from 'antlr4';
import { COOLLexer } from './antlrGenerated/COOLLexer';
import { COOLParser } from './antlrGenerated/COOLParser';

export default function parseCOOL(coolProgram: string) {
  const inputStream = new InputStream(coolProgram);
  const lexer = new COOLLexer(inputStream);
  const tokenStream = new CommonTokenStream(lexer);
  const parser = new COOLParser(tokenStream);
  parser.buildParseTrees = true;
  const coolAst = parser.program();
  return coolAst;
}
```

第一步稍微复杂一点，就是我们怎么得到上面的 ```COOLLexer``` 和 ```COOLParser``` 的？

### Antlr4

我使用了一个现代编译器编译器 Antlr4，就是把我对 COOL 语言的语法描述，编译成一个编译器的编译器，而且它很有现代感，可以编译出 Python、typescript、javascript、Java 等常用语言的 lexer 和 parser，可以大幅提高工程效率。

为 Antlr4 写的 COOL 语言语法大概长这样：

```rust
// COOL.g4
grammar COOL;

program: programBlocks;
programBlocks
  : classDefine ';' programBlocks #classes
  | EOF #eof
  ;
classDefine: CLASS TYPEID (INHERITS TYPEID)? '{' (feature ';')* '}';
```

意思是 program 是一个 programBlocks 数组，其中每个 programBlocks 是 classDefine 后面接上分号，或者是 end-of-file。
而 classDefine 是类似于 ```class ClassName inherits SuperClass （可以不inherits） { };``` 的样子。

写这一部分的时候，参照着 COOL 语言的手册，它一般会给出 Backus-Naur Form（BNF）的语法定义，如下图：



它的词法大概长这样：

```rust
// COOL.g4
// skip spaces, tabs, newlines, note that \v is not suppoted in antlr
WHITESPACE: [ \t\r\n\f]+ -> skip; 

// comments
OPEN_COMMENT: '(*';
CLOSE_COMMENT: '*)';
COMMENT: OPEN_COMMENT (COMMENT|.)*? CLOSE_COMMENT -> channel(HIDDEN);
ONE_LINE_COMMENT: '--' .*? '\n' -> channel(HIDDEN);

// key words
CLASS: C L A S S;
ELSE: E L S E ;
FALSE: 'f' A L S E ;
```